"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PROVIDERS = void 0;
var lichess_opening_1 = require("./providers/lichess-opening");
var lichess_cloud_eval_1 = require("./providers/lichess-cloud-eval");
var stockfish_eval_1 = require("./providers/stockfish-eval");
var chess_js_1 = require("chess.js");
var constants_1 = require("./constants");
//@ts-ignore
// const Chess = require('chess.js');
var PROVIDERS;
(function (PROVIDERS) {
    PROVIDERS["LICHESS_BOOK"] = "lichessOpening";
    PROVIDERS["LICHESS_CLOUD_EVAL"] = "lichessCloudEval";
    PROVIDERS["STOCKFISH"] = "stockfishEval";
})(PROVIDERS = exports.PROVIDERS || (exports.PROVIDERS = {}));
function clamp(value, min, max) {
    if (value > max) {
        return max;
    }
    else if (value < min) {
        return min;
    }
    return value;
}
function getProviderByName(providerName) {
    console.log(providerName);
    switch (providerName) {
        case PROVIDERS.LICHESS_CLOUD_EVAL:
            return lichess_cloud_eval_1.lichessCloudEval;
        case PROVIDERS.LICHESS_BOOK:
            return lichess_opening_1.lichessOpening;
        case PROVIDERS.STOCKFISH:
            return stockfish_eval_1.stockfishEval;
    }
}
function getResult(providers, params, namesOfProviders, originalResolve, originalReject) {
    var currentProvider = providers[0];
    var currentProviderName = namesOfProviders[0];
    //@ts-ignore
    return new Promise(function (resolve, reject) {
        var workerCallback = {
            resolve: originalResolve || resolve,
            reject: originalReject || reject,
        };
        currentProvider(params)
            .then(function (result) {
            workerCallback.resolve({
                result: result,
                providerName: currentProviderName, // provider function name
            });
        })
            .catch(function (error) {
            if (providers.length > 1) {
                providers.shift();
                namesOfProviders.shift();
                getResult(providers, params, namesOfProviders, workerCallback.resolve, workerCallback.reject);
            }
            else {
                workerCallback.reject({
                    errorLastProvider: error,
                    message: 'all providers not available',
                });
            }
        });
    });
}
function getAnalysis(params) {
    // fix optionals params
    params.multipv = clamp(params.multipv || constants_1.DEFAULT_MULTI_PV, constants_1.MIN_MULTI_PV, constants_1.MAX_MULTI_PV);
    params.depth = clamp(params.depth || constants_1.DEFAULT_DEPTH, constants_1.MIN_DEPTH, constants_1.MAX_DEPTH);
    var chessReferee = new chess_js_1.Chess(params.fen);
    var isValidFen = chessReferee.validate_fen(params.fen).valid;
    if (!isValidFen) {
        throw new Error("FEN is not valid, analysis has been aborted");
    }
    if (chessReferee.game_over()) {
        throw new Error("FEN position is already resolve");
    }
    var countPlayedMoves = parseInt(params.fen.split(' ').pop());
    var providersOrder = [];
    var namesOfProviders = [];
    if (countPlayedMoves < 15) {
        // [lichessOpening, lichessCloudEval, stockfishEval]
        providersOrder = [lichess_opening_1.lichessOpening, lichess_cloud_eval_1.lichessCloudEval, stockfish_eval_1.stockfishEval];
        namesOfProviders = [
            PROVIDERS.LICHESS_BOOK,
            PROVIDERS.LICHESS_CLOUD_EVAL,
            PROVIDERS.STOCKFISH,
        ];
    }
    else if (countPlayedMoves < 35) {
        // [lichessCloudEval, stockfishEval]
        providersOrder = [lichess_cloud_eval_1.lichessCloudEval, stockfish_eval_1.stockfishEval];
        namesOfProviders = [PROVIDERS.LICHESS_CLOUD_EVAL, PROVIDERS.STOCKFISH];
    }
    else {
        // stockfishEval
        providersOrder = [stockfish_eval_1.stockfishEval];
        namesOfProviders = [PROVIDERS.STOCKFISH];
    }
    if (params.excludes) {
        namesOfProviders = namesOfProviders.filter(function (provider) { return !params.excludes.includes(provider); });
        console.log('namesOfProviders: ', namesOfProviders);
        providersOrder = namesOfProviders.map(function (providerName) {
            return getProviderByName(providerName);
        });
    }
    return getResult(providersOrder, params, namesOfProviders);
}
exports.default = getAnalysis;
